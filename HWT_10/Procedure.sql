USE NORTHWND

--13.1
--Написать процедуру, которая возвращает самый крупный заказ для каждого из продавцов за определенный год. В результатах не
--может быть несколько заказов одного продавца, должен быть только один и самый крупный. В результатах запроса должны быть
--выведены следующие колонки: колонка с именем и фамилией продавца (FirstName и LastName – пример: Nancy Davolio), номер
--заказа и его стоимость. В запросе надо учитывать Discount при продаже товаров. Процедуре передается год, за который надо
--сделать отчет, и количество возвращаемых записей. Результаты запроса должны быть упорядочены по убыванию суммы заказа.
--Процедура должна быть реализована с использованием оператора SELECT и БЕЗ ИСПОЛЬЗОВАНИЯ КУРСОРОВ. Название функции
--соответственно GreatestOrders. Необходимо продемонстрировать использование этих процедур. Также помимо демонстрации
--вызовов процедур в скрипте Query.sql надо написать отдельный ДОПОЛНИТЕЛЬНЫЙ проверочный запрос для тестирования
--правильности работы процедуры GreatestOrders. Проверочный запрос должен выводить в удобном для сравнения с результатами
--работы процедур виде для определенного продавца для всех его заказов за определенный указанный год в результатах следующие
--колонки: имя продавца, номер заказа, сумму заказа. Проверочный запрос не должен повторять запрос, написанный в процедуре, - он
--должен выполнять только то, что описано в требованиях по нему. ВСЕ ЗАПРОСЫ ПО ВЫЗОВУ ПРОЦЕДУР ДОЛЖНЫ БЫТЬ
--НАПИСАНЫ В ФАЙЛЕ Query.sql – см. пояснение ниже в разделе «Требования к оформлению».
GO
IF OBJECT_ID('GreatestOrders') IS NOT NULL
DROP PROCEDURE GreatestOrders
GO
CREATE PROCEDURE GreatestOrders
	@Year int,
	@Num int
AS
	SELECT TOP(@Num) nt.Seller, o2.OrderID, nt.Price
	FROM (
		SELECT e.EmployeeID,
			CONCAT(e.FirstName, ' ', e.LastName) 'Seller',
			MAX(od.Quantity * (od.UnitPrice - (od.UnitPrice * od.Discount)))'Price'
		FROM Employees e
		JOIN Orders o ON o.EmployeeID = e.EmployeeID
		JOIN [Order Details] od ON od.OrderID = o.OrderID
		WHERE YEAR(o.OrderDate) = @Year
		GROUP BY e.EmployeeID, CONCAT(e.FirstName, ' ', e.LastName)
	) nt, Orders o2
	JOIN [Order Details] od2 ON od2.OrderID = o2.OrderID
	WHERE o2.EmployeeID = nt.EmployeeID AND (od2.Quantity * (od2.UnitPrice - (od2.UnitPrice * od2.Discount))) = nt.Price
	ORDER BY 'Price' DESC
GO

--13.2
--Написать процедуру, которая возвращает заказы в таблице Orders, согласно указанному сроку доставки в днях
--(разница между OrderDate и ShippedDate). В результатах должны быть возвращены заказы, срок которых превышает переданное
--значение или еще недоставленные заказы. Значению по умолчанию для передаваемого срока 35 дней. Название
--процедуры ShippedOrdersDiff. Процедура должна высвечивать следующие колонки: OrderID, OrderDate, ShippedDate,
--ShippedDelay (разность в днях между ShippedDate и OrderDate), SpecifiedDelay (переданное в процедуру значение).
--Необходимо продемонстрировать использование этой процедуры.
GO
IF OBJECT_ID('ShippedOrdersDiff') IS NOT NULL
DROP PROCEDURE ShippedOrdersDiff
GO
CREATE PROCEDURE ShippedOrdersDiff
	@Days int = 35
AS
	SELECT OrderID, OrderDate, ShippedDate, DAY(ShippedDate - OrderDate) 'ShippedDelay', @Days 'SpecifiedDelay'
	FROM Orders
	WHERE DAY(ShippedDate - OrderDate) > @Days OR ShippedDate IS NULL
GO

--13.3
--Написать процедуру, которая высвечивает всех подчиненных заданного продавца, как непосредственных, так и подчиненных его
--подчиненных. В качестве входного параметра функции используется EmployeeID. Необходимо распечатать имена
--подчиненных и выровнять их в тексте (использовать оператор PRINT) согласно иерархии подчинения. Продавец, для которого
--надо найти подчиненных также должен быть высвечен. Название процедуры SubordinationInfo. В качестве алгоритма для решения
--этой задачи надо использовать пример, приведенный в Books Online и рекомендованный Microsoft для решения подобного типа
--задач. Продемонстрировать использование процедуры.
--//Какой ещё пример?
GO
IF OBJECT_ID('SubordinationInfo') IS NOT NULL
DROP PROCEDURE SubordinationInfo
GO
CREATE PROCEDURE SubordinationInfo
	@EmpID int,
	@Tabs int = 0
AS
	DECLARE @Name varchar(50)
	SELECT @Name = CONCAT(LastName, ' ', FirstName)
	FROM Employees
	WHERE @EmpID = EmployeeID
	SET @Name = CONCAT(SPACE(@Tabs * 4), @Name)
	PRINT @Name;
	
	SET @Tabs = @Tabs + 1;
	DECLARE @I int = 0
	WHILE(1 = 1)
		BEGIN
		SELECT @I = MIN(EmployeeID)
		FROM Employees WHERE EmployeeID > @I
		IF @I IS NULL BREAK
		IF EXISTS (
			SELECT ReportsTo FROM Employees
			WHERE ReportsTo = @EmpID AND @I = EmployeeID
			)
		EXEC SubordinationInfo @I, @Tabs
		END
GO

--13.4
--Написать функцию, которая определяет, есть ли у продавца подчиненные. Возвращает тип данных BIT. В качестве входного
--параметра функции используется EmployeeID. Название функции IsBoss. Продемонстрировать использование функции для всех
--продавцов из таблицы Employees.
GO
IF OBJECT_ID('IsBoss') IS NOT NULL
DROP FUNCTION IsBoss
GO
CREATE FUNCTION IsBoss (
	@EmpID int
	)
RETURNS bit
BEGIN
	DECLARE @Flag bit = 0
	IF EXISTS (
		SELECT EmployeeID
		FROM Employees
		WHERE ReportsTo = @EmpID
		)
	SET @Flag = 1;

	RETURN @Flag
END